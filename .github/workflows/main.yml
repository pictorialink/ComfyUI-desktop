name: macOS Build

on:
  push:
    tags:
      - 'v*'

jobs:
  build:
    runs-on: macos-latest

    steps:
    - name: Set TAG environment variable
      run: |
        TAG="${GITHUB_REF#refs/tags/}"
        echo "TAG=$TAG" >> $GITHUB_ENV
        echo "Setting TAG to $TAG"

    - name: Checkout repository
      uses: actions/checkout@v4

    - name: Free disk space
      run: |
        echo "Disk space before cleanup:"
        df -h
        
        # 删除不必要的大型软件包和缓存
        sudo rm -rf /usr/local/share/boost
        sudo rm -rf /usr/share/dotnet
        sudo rm -rf /usr/local/lib/android
        sudo rm -rf /Library/Java
        brew cleanup
        
        echo "Disk space after cleanup:"
        df -h

    - name: Use Node.js 20.x
      uses: JP250552/setup-node@0c618ceb2e48275dc06e86901822fd966ce75ba2
      with:
        node-version: '20.x'
        corepack: true

    - name: Install dependencies
      run: |
        yarn install

    - name: Run electron-rebuild
      run: |
        npx electron-rebuild
        
    # 导入证书并确保安全存储
    - uses: apple-actions/import-codesign-certs@v1
      name: 安装 Apple 证书
      with:
        p12-file-base64: ${{ secrets.APP_BASE64 }}
        p12-password: ${{ secrets.P12_PASSWORD }}
        keychain-password: ${{ secrets.KEYCHAIN_PASSWORD || github.run_id }}
        create-keychain: true
        keychain: build
    
    # 创建公证配置文件 - 使用统一的命名
    - name: 配置公证凭证
      run: |
        # 创建公证工具凭据配置
        xcrun notarytool store-credentials "notary-profile" \
          --apple-id "${{ secrets.USER_NAME }}" \
          --team-id "${{ secrets.TEAM_ID }}" \
          --password "${{ secrets.ACCOUNT_PASSWORD }}"
        
        # 验证证书和配置文件
        security find-identity -p codesigning build.keychain
        xcrun notarytool info --keychain-profile "notary-profile" || echo "凭证配置需要提交时验证"

    - name: Build and package project
      env:
        CSC_LINK: ${{ secrets.APP_BASE64 }}
        CSC_KEY_PASSWORD: ${{ secrets.P12_PASSWORD }}
        APPLE_ID: ${{ secrets.USER_NAME }}
        APPLE_APP_SPECIFIC_PASSWORD: ${{ secrets.ACCOUNT_PASSWORD }}
        APPLE_TEAM_ID: ${{ secrets.TEAM_ID }}
        GITHUB_TOKEN: ${{ secrets.GH_TOKEN }}
      run: |
        echo "Building project with DMG packaging..."

        yarn make

        # 清理构建缓存以释放空间
        rm -rf node_modules/.cache
        
        # 确定输出目录
        PROJECT_DIR=$(pwd)
        echo "Output directories in $PROJECT_DIR/dist:"
        ls -la $PROJECT_DIR/dist/
        
        # 检查mac-arm64目录是否存在
        if [ -d "$PROJECT_DIR/dist/mac-arm64" ]; then
          OUTPUT_DIR="$PROJECT_DIR/dist/mac-arm64"
        else
          # 找到可能的其他目录
          OUTPUT_DIR=$(find "$PROJECT_DIR/dist" -type d -name "mac*" | head -1)
        fi
        echo "Using output directory: $OUTPUT_DIR"
        ls -la "$OUTPUT_DIR"
        
        # 查找.app文件
        APP_PATH=$(find "$OUTPUT_DIR" -name "*.app" -type d | head -1)
        if [ -z "$APP_PATH" ]; then
          echo "No .app file found in output directory!"
          exit 1
        fi
        
        APP_NAME=$(basename "$APP_PATH" .app)
        echo "Found app: $APP_NAME"
        
        # 确认entitlements文件存在
        if [ ! -f "./Release.entitlements" ]; then
          echo "Release.entitlements file not found!"
          exit 1
        fi
        
        # 进行深度代码签名 - 先签名内部组件
        echo "Signing app at: $APP_PATH"
        find "$APP_PATH/Contents/Frameworks" -name "*.framework" -o -name "*.dylib" | while read -r framework; do
          echo "Signing framework: $framework"
          codesign --force --options runtime --timestamp --sign "${{secrets.IDENTITY_NAME}}" "$framework" --deep --verbose
        done
        
        # 签名主应用
        codesign --force --options runtime --entitlements ./Release.entitlements --timestamp --sign "${{secrets.IDENTITY_NAME}}" "$APP_PATH" --deep --verbose
        
        # 验证应用签名
        echo "Verifying app signature:"
        codesign --verify --verbose=2 "$APP_PATH"
        
        # 创建临时目录用于DMG打包
        DMG_DIR="$OUTPUT_DIR/dmg_temp"
        mkdir -p "$DMG_DIR"
        
        # 确定DMG名称
        DMG_NAME="${APP_NAME}_${TAG}.dmg"
        echo "DMG_NAME=$DMG_NAME" >> $GITHUB_ENV
        
        # 将应用程序复制到临时目录
        cp -R "$APP_PATH" "$DMG_DIR/"
        
        # 确定DMG路径
        DMG_PATH="$OUTPUT_DIR/$DMG_NAME"
        echo "DMG_PATH=$DMG_PATH" >> $GITHUB_ENV
        
        # 创建DMG
        hdiutil create -volname "$APP_NAME" -srcfolder "$DMG_DIR" -ov -format UDZO "$DMG_PATH"
        
        echo "DMG 创建完成: $DMG_PATH"
        
        # 验证DMG是否成功创建
        if [ ! -f "$DMG_PATH" ]; then
          echo "DMG file was not created successfully!"
          exit 1
        fi
        
        # 签名DMG
        codesign --force --sign "${{secrets.IDENTITY_NAME}}" --timestamp "$DMG_PATH" --verbose
        
        # 提交到公证服务并等待结果 - 使用专门的公证配置文件
        echo "Submitting DMG for notarization - this may take several minutes..."
        xcrun notarytool submit "$DMG_PATH" \
          --keychain-profile "notary-profile" \
          --wait \
          --timeout 2h
        
        # 检查最近的公证历史
        echo "Checking notarization history..."
        SUBMISSION_ID=$(xcrun notarytool history --keychain-profile "notary-profile" | grep "$DMG_NAME" | head -1 | awk '{print $1}')
        
        if [ -n "$SUBMISSION_ID" ]; then
          echo "Found submission ID: $SUBMISSION_ID"
          echo "Checking notarization status..."
          xcrun notarytool info --keychain-profile "notary-profile" "$SUBMISSION_ID"
          
          # 确认公证状态
          STATUS=$(xcrun notarytool info --keychain-profile "notary-profile" "$SUBMISSION_ID" | grep "status:" | awk '{print $2}')
          if [ "$STATUS" == "Accepted" ]; then
            echo "Notarization successful! Proceeding with stapling..."
            
            # 注入公证票据到DMG
            echo "Stapling notarization ticket to DMG..."
            xcrun stapler staple "$DMG_PATH"
            
            # 验证签章
            echo "Validating staple..."
            xcrun stapler validate "$DMG_PATH"
            
            # 记录成功状态
            echo "NOTARIZATION_SUCCESS=true" >> $GITHUB_ENV
          else
            echo "Notarization status is not 'Accepted' (Status: $STATUS). Skipping stapling but continuing..."
            echo "NOTARIZATION_SUCCESS=false" >> $GITHUB_ENV
          fi
        else
          echo "Could not find submission ID in notarization history. Skipping stapling..."
          echo "NOTARIZATION_SUCCESS=false" >> $GITHUB_ENV
        fi
        
        # 删除临时目录
        rm -rf "$DMG_DIR"
    
    - name: Check DMG file
      run: |
        if [ ! -f "${{ env.DMG_PATH }}" ]; then
          echo "DMG file not found"
          exit 1
        fi

        # 显示文件信息
        ls -la "${{ env.DMG_PATH }}"
        
        # 检查签名
        echo "Checking DMG signature:"
        codesign -dv --verbose=4 "${{ env.DMG_PATH }}" || echo "Signature verification warning - continuing anyway"
        
        # 检查公证签章
        if [ "${{ env.NOTARIZATION_SUCCESS }}" == "true" ]; then
          echo "Checking DMG staple:"
          xcrun stapler validate "${{ env.DMG_PATH }}" || echo "Staple validation warning - continuing anyway"
          
          echo "Running spctl assessment:"
          spctl --assess --verbose=4 --type open --context context:primary-signature "${{ env.DMG_PATH }}"
        else
          echo "Skipping staple validation as notarization was not successful"
        fi

    # 发布 DMG 到 Release
    - name: Create Release
      uses: softprops/action-gh-release@v1
      with:
        files: "${{ env.DMG_PATH }}"
        name: "ComfyUI Desktop ${{ env.TAG }}"
        body: |
          # ComfyUI Desktop ${{ env.TAG }} for macOS
          
          ${{ env.NOTARIZATION_SUCCESS == 'true' && '✅ 此版本已通过 Apple 公证，可直接打开使用。' || '⚠️ 此版本可能未通过 Apple 公证，首次打开时请在"系统设置"中手动允许应用运行。' }}
          
          ## 安装说明
          1. 下载 DMG 文件
          2. 打开 DMG 并将应用拖动到应用程序文件夹
          3. 首次运行时右键点击应用并选择"打开"
        draft: false
        prerelease: false
      env:
        GITHUB_TOKEN: ${{ secrets.GH_TOKEN }}
    
    - name: Send success notification to WeChat
      if: success()
      run: |
        WEBHOOK="${{ secrets.WECHAT_HOOK }}"
        NOTARIZATION_STATUS="${{ env.NOTARIZATION_SUCCESS == 'true' && '（已公证）' || '（未公证）' }}"
        curl -X POST "$WEBHOOK" \
        -H 'Content-Type: application/json' \
        -d '{
              "msgtype": "text",
              "text": {
                "content": "构建成功: ComfyUI Desktop ${{ env.TAG }} '$NOTARIZATION_STATUS' 已发布。下载地址: https://github.com/${{ github.repository }}/releases/download/${{ env.TAG }}/${{ env.DMG_NAME }}"
              }
            }'

    - name: Send failure notification to WeChat
      if: failure()
      run: |
        WEBHOOK="${{ secrets.WECHAT_HOOK }}"
        curl -X POST "$WEBHOOK" \
        -H 'Content-Type: application/json' \
        -d '{
              "msgtype": "text",
              "text": {
                "content": "构建失败: ComfyUI Desktop ${{ env.TAG }} 构建过程中出现错误。"
              }
            }'